import { Meta } from "@storybook/addon-docs";

<Meta title="Slots Spike" />

<style>{`
`}</style>

# slot-spike

A spike for Fluent UI vNext slots

The goal is to compare the capabilities of two approaches:

- The existing Fluent UI vNext attribute-based slots
  = Using props.children to provide slots

## Stories

### Capabilities

- I can slot an only child, named child/children, list, or hierarchy of content.
- I can read the props of slotted content.
- I can modify the rendering (order, arrangement) of content.
- I can modify the props of slotted content.
- I can modify the classes/style of slotted content.
- I can subscribe to an event from slotted content (wrap to leave child event intact)

### Types of slot content

- I can slot primitive values.
- I can slot HTML elements.
- I can slot JSX.
- I can slot render functions.
- I can slot props //applies only to the attributes approach
- I can slot a heterogeneous list/hierarchy of children. //may only apply to props.children approach

### Types of children

- I can slot a single child as content.
- I can slot a list of children as content.
- I can slot a hiearchy of children.

## Findings

- There aren't any technical limitations to the attributes or props.children approaches.
- Both approaches require about the same amount of helper code to navigate and manipulate slotted content.

- The props.children approach is more idomatic web development. Elements are defined in JSX, data is passed on attributes.
- The props.children approach provides type, key, ref, and component name inspection for free. The attributes approach will require defining new types and some inspection code.
- The props.children approach provides more rendering performance control to the caller (although memoization of render results is discouraged over data)

- The attributes approach provides better discovery than props.children because the attributes are defined and documented in the pros of the component.
- The attributes approach introduces the challenge of where to apply props (root element or logically associated element).
- The attributes approach allows for render function pointers to be passed to the component. This lets the component control delayed or conditional rendering.

- List virtualization libraries most often have an items attribute that accepts a data array.
  The item template is defined as the singular child in react-window, but grouped item scenarios may require attributes to handle multiple templates.

## Conclusions

- Fluent's philosophy of slots can guide when to use attributes vs. props.children.
  - If a Fluent component provide a fixed set of layouts and a restricted set of slots for the parts that are designed to be replaced,
    then the attributes approach would work well.
    Slotted content would likely be singular or small bits of JSX.
  - If a Fluent component provides a default layout and slotted content, but callers can replace the layout,
    then the props.children approach would work well.
    The children could be any hierarchy callers wanted where individual parts are identified as slots.
    The component would wire up the behavior to the slots.

## Appendix: props.children format

### When children is a primitive

```ts
children: <value of primitive>
```

### When children is an HTML element

```ts
children: {
  $$typeof: Symbol(react.element)
  props: {
    children: <value within the element>
  }
  type: <element type (like div or label)>
}
```

### When children is a single component child

```ts
children: {
  $$typeof: Symbol(react.element)
  props: {
    children: <value within the component>
  }
  type: props => {...}
    displayName: <ComponentName>
    name: <ComponentName>
}
```

### When children is multiple HTML elements or components

```ts
children: [
  {
    $$typeof: Symbol(react.element),
    type: <element type (like div or label)>
    key: <value of key attribute>,
    ref: <reference if any>
    props: {
      children: <value within the element>
    }
  }
]
```
